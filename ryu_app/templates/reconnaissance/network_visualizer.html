{% extends "reconnaissance/base.html" %}

{% block title %}Network Mapping Visualizer{% endblock %}

{% block extra_styles %}
    :root { --accent-color: #8b5cf6; }
    #cy {
        width: 100% !important;
        height: calc(100vh - 350px) !important;
        min-height: 600px;
        border: 1px solid #334155;
        border-radius: 8px;
        background: #0f172a;
    }
    .graph-container {
        flex: 1 0 1700px; /* flex-grow: 1, flex-shrink: 0, flex-basis: 1700px - prevents shrinking below 1700px */
        min-width: 1700px;
        position: relative;
        width: 100%;
        height: calc(100vh - 350px);
        min-height: 600px;
    }
    .visualization-center-container {
        display: flex;
        justify-content: center;
        width: 100%;
        margin-top: 20px;
    }
    .visualization-layout-wrapper {
        width: auto;
        min-width: 2440px; /* 350px (left panel) + 20px (gap) + 1700px (graph) + 20px (gap) + 350px (right panel - always visible) */
        overflow-x: auto; /* Allow horizontal scrolling if needed */
    }
    .graph-container {
        flex: 1;
        min-width: 0;
        position: relative;
    }
    /* Scrollbar styling for side panels */
    #visual-controls-panel,
    #node-details-panel {
        scrollbar-width: thin;
        scrollbar-color: #334155 #1e293b;
    }
    #visual-controls-panel::-webkit-scrollbar,
    #node-details-panel::-webkit-scrollbar {
        width: 8px;
    }
    #visual-controls-panel::-webkit-scrollbar-track,
    #node-details-panel::-webkit-scrollbar-track {
        background: #1e293b;
        border-radius: 4px;
    }
    #visual-controls-panel::-webkit-scrollbar-thumb,
    #node-details-panel::-webkit-scrollbar-thumb {
        background: #334155;
        border-radius: 4px;
    }
    #visual-controls-panel::-webkit-scrollbar-thumb:hover,
    #node-details-panel::-webkit-scrollbar-thumb:hover {
        background: #475569;
    }
    .controls-panel {
        background: rgba(30, 41, 59, 0.8);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        border: 1px solid #334155;
    }
    .control-group {
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 15px;
    }
    .control-group label {
        color: #94a3b8;
        font-size: 0.9rem;
        min-width: 100px;
    }
    .control-group select,
    .control-group input {
        padding: 8px 12px;
        background: #1e293b;
        border: 1px solid #334155;
        border-radius: 6px;
        color: #e2e8f0;
        font-size: 0.9rem;
    }
    .control-group button {
        padding: 8px 16px;
        background: #8b5cf6;
        border: none;
        border-radius: 6px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.3s;
    }
    .control-group button:hover {
        background: #7c3aed;
    }
    .stats-panel {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        margin-bottom: 15px;
    }
    .stat-item {
        padding: 10px 15px;
        background: rgba(59, 130, 246, 0.1);
        border-radius: 6px;
        border: 1px solid rgba(59, 130, 246, 0.3);
    }
    .stat-item .label {
        color: #94a3b8;
        font-size: 0.8rem;
    }
    .stat-item .value {
        color: #3b82f6;
        font-size: 1.2rem;
        font-weight: bold;
    }
    .visual-control-section {
        background: rgba(15, 23, 42, 0.6);
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #334155;
    }
    .control-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
    }
    .control-item label {
        color: #94a3b8;
        font-size: 0.85rem;
        min-width: 120px;
    }
    .control-item input[type="range"] {
        flex: 1;
        max-width: 150px;
    }
    /* Node list styling */
    #node-list-container {
        scrollbar-width: thin;
        scrollbar-color: #334155 #1e293b;
    }
    #node-list-container::-webkit-scrollbar {
        width: 6px;
    }
    #node-list-container::-webkit-scrollbar-track {
        background: #1e293b;
        border-radius: 3px;
    }
    #node-list-container::-webkit-scrollbar-thumb {
        background: #334155;
        border-radius: 3px;
    }
    #node-list-container::-webkit-scrollbar-thumb:hover {
        background: #475569;
    }
    .node-list-item {
        padding: 10px 12px;
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid #334155;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.9rem;
        color: #e2e8f0;
    }
    .node-list-item:hover {
        background: rgba(59, 130, 246, 0.2);
        border-color: #3b82f6;
    }
    .node-list-item.selected {
        background: rgba(59, 130, 246, 0.3);
        border-color: #3b82f6;
        border-width: 2px;
        font-weight: 600;
    }
    .node-list-item .node-type {
        font-size: 0.75rem;
        color: #94a3b8;
        text-transform: uppercase;
        margin-bottom: 4px;
    }
    .node-list-item .node-label {
        color: #e2e8f0;
    }
{% endblock %}

{% block content %}
<a href="/reconnaissance/" class="back-link">‚Üê Back to Reconnaissance</a>

<div class="page-header">
    <div class="icon">üó∫Ô∏è</div>
    <div>
        <h2>Network Mapping Visualizer</h2>
        <p class="subtitle">Interactive visualization of IP addresses, CIDR blocks, and ASN relationships with Egg IP mapping</p>
    </div>
</div>

<div class="controls-panel">
    <div class="stats-panel" id="stats-panel">
        <div class="stat-item">
            <div class="label">Nodes</div>
            <div class="value" id="stat-nodes">0</div>
        </div>
        <div class="stat-item">
            <div class="label">Edges</div>
            <div class="value" id="stat-edges">0</div>
        </div>
        <div class="stat-item">
            <div class="label">IP Nodes</div>
            <div class="value" id="stat-ip-nodes">0</div>
        </div>
        <div class="stat-item">
            <div class="label">CIDR Blocks</div>
            <div class="value" id="stat-cidr-nodes">0</div>
        </div>
        <div class="stat-item">
            <div class="label">ASNs</div>
            <div class="value" id="stat-asn-nodes">0</div>
        </div>
        <div class="stat-item">
            <div class="label">Scanned IPs</div>
            <div class="value" id="stat-scanned-ips">0</div>
        </div>
        <div class="stat-item">
            <div class="label">Unscanned IPs</div>
            <div class="value" id="stat-unscanned-ips">0</div>
        </div>
    </div>
    
    <div class="control-group">
        <label>Egg Name:</label>
        <select id="eggname-select">
            <option value="">All Eggs</option>
        </select>
        
        <label>Project Egg:</label>
        <select id="projectegg-select">
            <option value="">All Projects</option>
        </select>
        
        <label>View Level:</label>
        <select id="level-select">
            <option value="all">All (IP ‚Üí CIDR ‚Üí ASN)</option>
            <option value="ip">IP Addresses Only</option>
            <option value="cidr">CIDR Blocks Only</option>
            <option value="asn">ASNs Only</option>
        </select>
        
        <label>Filter ASN:</label>
        <input type="text" id="asn-filter" placeholder="e.g., 13335" style="width: 120px;">
        
        <label>
            <input type="checkbox" id="only-scanned-eggs"> Only Scanned Eggs
        </label>
        
        <button onclick="loadGraph()">üîÑ Refresh Graph</button>
        <button onclick="resetView()">üéØ Reset View</button>
        <button onclick="zoomIn()" title="Zoom In">üîç+ Zoom In</button>
        <button onclick="zoomOut()" title="Zoom Out">üîç- Zoom Out</button>
        <label style="margin-left: 10px; display: flex; align-items: center; gap: 8px;">
            <span style="font-size: 0.85rem; color: #94a3b8;">Zoom:</span>
            <input type="range" id="zoom-slider" min="0.1" max="3" step="0.05" value="1" style="width: 120px;" oninput="setZoom(this.value)">
            <span id="zoom-value" style="color: #94a3b8; font-size: 0.85rem; min-width: 50px;">100%</span>
        </label>
    </div>
</div>

<!-- Centering Container - Wraps visualization layout to center it -->
<div class="visualization-center-container">
    <!-- Visualization Layout - Three panel flex container -->
    <div class="visualization-layout-wrapper" style="display: flex; gap: 20px; align-items: flex-start;">
    <!-- Visual Control Panel - Left Side (Fixed width) -->
    <div id="visual-controls-panel" class="controls-panel" style="flex: 0 0 350px; background: rgba(59, 130, 246, 0.1); border: 2px solid #3b82f6; border-radius: 8px; padding: 20px; height: calc(100vh - 350px); min-height: 600px; overflow-y: auto;">
        <h4 style="color: #3b82f6; margin-bottom: 15px; font-size: 1.1rem;">üé® Visual Controls</h4>
        <div style="display: flex; flex-direction: column; gap: 20px;">
            <!-- Node Controls -->
            <div class="visual-control-section">
                <h5 style="color: #e2e8f0; margin-bottom: 10px; font-size: 0.95rem;">Node Settings</h5>
                <div class="control-item">
                    <label>Scanned IP Color:</label>
                    <input type="color" id="node-color-scanned" value="#3b82f6" style="width: 60px; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                </div>
                <div class="control-item">
                    <label>Unscanned IP Color:</label>
                    <input type="color" id="node-color-unscanned" value="#94a3b8" style="width: 60px; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                </div>
                <div class="control-item">
                    <label>CIDR Node Color:</label>
                    <input type="color" id="node-color-cidr" value="#10b981" style="width: 60px; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                </div>
                <div class="control-item">
                    <label>ASN Node Color:</label>
                    <input type="color" id="node-color-asn" value="#f59e0b" style="width: 60px; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                </div>
                <div class="control-item">
                    <label>Node Size:</label>
                    <input type="range" id="node-size" min="10" max="100" value="30" style="width: 120px;">
                    <span id="node-size-value" style="color: #94a3b8; margin-left: 10px;">30px</span>
                </div>
            </div>
            
            <!-- Edge/Line Controls -->
            <div class="visual-control-section">
                <h5 style="color: #e2e8f0; margin-bottom: 10px; font-size: 0.95rem;">Edge/Line Settings</h5>
                <div class="control-item">
                    <label>Edge Color:</label>
                    <input type="color" id="edge-color" value="#64748b" style="width: 60px; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                </div>
                <div class="control-item">
                    <label>Line Width:</label>
                    <input type="range" id="edge-width" min="0.5" max="10" step="0.1" value="1" style="width: 120px;">
                    <span id="edge-width-value" style="color: #94a3b8; margin-left: 10px;">1px</span>
                </div>
                <div class="control-item">
                    <label>Network Edge Color:</label>
                    <input type="color" id="edge-color-network" value="#8b5cf6" style="width: 60px; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                </div>
                <div class="control-item">
                    <label>Project Edge Color:</label>
                    <input type="color" id="edge-color-project" value="#ec4899" style="width: 60px; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                </div>
                <div class="control-item">
                    <label>
                        <input type="checkbox" id="weight-based-coloring" checked style="margin-right: 8px;">
                        Color by Relationship Weight (Intelligence-Based)
                    </label>
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 4px; margin-left: 24px;">
                        High (‚â•0.75): Red | Medium (0.5-0.75): Orange | Low (&lt;0.5): Grey/Dashed
                    </div>
                </div>
            </div>
            
            <!-- Layout Controls -->
            <div class="visual-control-section">
                <h5 style="color: #e2e8f0; margin-bottom: 10px; font-size: 0.95rem;">Layout Settings</h5>
                <div class="control-item">
                    <label>Layout Type:</label>
                    <select id="layout-type" style="width: 150px;">
                        <option value="dagre">Dagre (Hierarchical)</option>
                        <option value="cose">CoSE (Force-Directed)</option>
                        <option value="breadthfirst">Breadthfirst</option>
                        <option value="grid">Grid</option>
                        <option value="circle">Circle</option>
                    </select>
                </div>
                <div class="control-item">
                    <label>
                        <input type="checkbox" id="clustered-drag" checked style="margin-right: 8px;">
                        Clustered Drag (Move Neighbors)
                    </label>
                </div>
                <div class="control-item">
                    <button onclick="applyLayout()" style="padding: 8px 16px; background: #8b5cf6; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600; width: 100%;">
                        Apply Layout
                    </button>
                </div>
            </div>
            
            <!-- Physics Controls (for force-directed layouts) -->
            <div class="visual-control-section" id="physics-controls" style="display: none;">
                <h5 style="color: #e2e8f0; margin-bottom: 10px; font-size: 0.95rem;">Physics Controls</h5>
                <div class="control-item">
                    <label>Link Force (Attraction):</label>
                    <input type="range" id="link-force" min="0.1" max="5" step="0.1" value="1.5" style="width: 120px;">
                    <span id="link-force-value" style="color: #94a3b8; margin-left: 10px;">1.5</span>
                </div>
                <div class="control-item">
                    <label>Link Distance:</label>
                    <input type="range" id="link-distance" min="20" max="200" step="10" value="30" style="width: 120px;">
                    <span id="link-distance-value" style="color: #94a3b8; margin-left: 10px;">30px</span>
                </div>
                <div class="control-item">
                    <label>Repel Force:</label>
                    <input type="range" id="repel-force" min="0.1" max="10" step="0.1" value="5" style="width: 120px;">
                    <span id="repel-force-value" style="color: #94a3b8; margin-left: 10px;">5.0</span>
                </div>
                <div class="control-item">
                    <label>Center Force:</label>
                    <input type="range" id="center-force" min="0" max="2" step="0.1" value="0.5" style="width: 120px;">
                    <span id="center-force-value" style="color: #94a3b8; margin-left: 10px;">0.5</span>
                </div>
                <div style="font-size: 0.75rem; color: #64748b; margin-top: 10px; padding-top: 10px; border-top: 1px solid #334155;">
                    Changes apply automatically as you adjust the sliders
                </div>
            </div>
            
            <!-- Node Color Assignment -->
            <div class="visual-control-section">
                <h5 style="color: #e2e8f0; margin-bottom: 10px; font-size: 0.95rem;">Custom Node Colors</h5>
                <div class="control-item">
                    <label>Select Node Type:</label>
                    <select id="node-type-select" style="width: 150px;">
                        <option value="ip_scanned">Scanned IP</option>
                        <option value="ip_unscanned">Unscanned IP</option>
                        <option value="cidr">CIDR Block</option>
                        <option value="asn">ASN</option>
                    </select>
                </div>
                <div class="control-item">
                    <label>Custom Color:</label>
                    <input type="color" id="custom-node-color" value="#3b82f6" style="width: 60px; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                </div>
                <div class="control-item">
                    <button onclick="assignNodeColor()" style="padding: 8px 16px; background: #8b5cf6; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600;">
                        Assign Color
                    </button>
                </div>
            </div>
        </div>
        <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
            <button onclick="resetVisualSettings()" style="padding: 10px 20px; background: #64748b; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600;">
                Reset to Defaults
            </button>
            <button onclick="applyVisualSettings()" style="padding: 10px 20px; background: #10b981; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600;">
                ‚úÖ Apply & Save
            </button>
        </div>
    </div>
    
    <!-- Graph Panel - Center (Flexible, fills remaining space) -->
    <div class="graph-container" style="flex: 1 1 auto; position: relative; width: 100%;">
        <div id="cy" style="width: 100%; height: 100%;"></div>
    </div>
    
    <!-- Node Details Panel - Right Side (Fixed width, always visible) -->
    <div id="node-details-panel" class="controls-panel" style="flex: 0 0 350px; background: rgba(59, 130, 246, 0.1); border: 2px solid #3b82f6; border-radius: 8px; padding: 20px; height: calc(100vh - 350px); min-height: 600px; overflow-y: auto; display: flex; flex-direction: column;">
        <h4 style="color: #3b82f6; margin-bottom: 15px; font-size: 1.1rem;">üìã Node List</h4>
        
        <!-- Node List Section -->
        <div id="node-list-container" style="flex: 1; overflow-y: auto; margin-bottom: 20px; border-bottom: 1px solid #334155; padding-bottom: 20px;">
            <div id="node-list" style="display: flex; flex-direction: column; gap: 8px;">
                <!-- Node list will be populated here -->
            </div>
        </div>
        
        <!-- Node Details Section (shown when node is selected) -->
        <div id="node-details-content" style="color: #e2e8f0; display: none;">
            <!-- Node details will be shown here -->
        </div>
    </div>
</div>
</div>

<div style="margin-top: 20px; padding: 15px; background: rgba(30, 41, 59, 0.8); border-radius: 8px; border: 1px solid #334155;">
    <h4 style="color: #e2e8f0; margin-bottom: 15px; font-size: 1.1rem;">üìñ Color Legend</h4>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; color: #e2e8f0; font-size: 0.9rem;">
        <div style="display: flex; align-items: center; gap: 8px;">
            <div style="width: 20px; height: 20px; background: #3b82f6; border-radius: 50%;"></div>
            <span>Scanned IP Address</span>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
            <div style="width: 20px; height: 20px; background: #94a3b8; border-radius: 50%; opacity: 0.6;"></div>
            <span>Unscanned IP Address</span>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
            <div style="width: 30px; height: 30px; background: #10b981; border-radius: 8px;"></div>
            <span>CIDR Block Node</span>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
            <div style="width: 35px; height: 35px; background: #f59e0b; border-radius: 8px;"></div>
            <span>ASN Node</span>
        </div>
    </div>
    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #334155;">
        <h5 style="color: #e2e8f0; margin-bottom: 10px; font-size: 1rem;">Connection Types</h5>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; color: #e2e8f0; font-size: 0.9rem;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 40px; height: 2px; background: #3b82f6; position: relative;">
                    <div style="position: absolute; right: -5px; top: -3px; width: 0; height: 0; border-left: 5px solid #3b82f6; border-top: 3px solid transparent; border-bottom: 3px solid transparent;"></div>
                </div>
                <span>belongs to (IP ‚Üí CIDR)</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 40px; height: 2px; background: #10b981; position: relative;">
                    <div style="position: absolute; right: -5px; top: -3px; width: 0; height: 0; border-left: 5px solid #10b981; border-top: 3px solid transparent; border-bottom: 3px solid transparent;"></div>
                </div>
                <span>owned by (CIDR ‚Üí ASN)</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 40px; height: 2px; background: #8b5cf6; border-style: dashed; position: relative;">
                    <div style="position: absolute; right: -5px; top: -3px; width: 0; height: 0; border-left: 5px solid #8b5cf6; border-top: 3px solid transparent; border-bottom: 3px solid transparent;"></div>
                </div>
                <span>same network (IP ‚Üî IP)</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 40px; height: 2px; background: #ec4899; border-style: dotted; position: relative;">
                    <div style="position: absolute; right: -5px; top: -3px; width: 0; height: 0; border-left: 5px solid #ec4899; border-top: 3px solid transparent; border-bottom: 3px solid transparent;"></div>
                </div>
                <span>same project (IP ‚Üî IP)</span>
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
<script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
<script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>

<script>
let cy;
let graphData = { nodes: [], edges: [] };
let selectedNode = null; // Store currently selected node for color updates

// Function to update node color (called from node details panel)
function updateNodeColor(color) {
    if (!selectedNode) {
        console.warn('No node selected');
        return;
    }
    
    if (!cy) {
        console.warn('Cytoscape not initialized');
        return;
    }
    
    // Update the node's style directly
    selectedNode.style('background-color', color);
    selectedNode.style('border-color', color);
    
    // Log the change
    const nodeId = selectedNode.id();
    const nodeLabel = selectedNode.data('label');
    console.log(`Updated node ${nodeId} (${nodeLabel}) color to ${color}`);
}

// Load dropdown options
async function loadDropdownOptions() {
    try {
        console.log('Loading dropdown options...');
        const response = await fetch('/reconnaissance/api/network/options/');
        
        if (!response.ok) {
            console.error('API response not OK:', response.status, response.statusText);
            return;
        }
        
        const data = await response.json();
        console.log('Dropdown options data:', data);
        
        if (data.success) {
            const eggnameSelect = document.getElementById('eggname-select');
            const projecteggSelect = document.getElementById('projectegg-select');
            
            if (!eggnameSelect || !projecteggSelect) {
                console.error('Dropdown elements not found!');
                return;
            }
            
            // Clear existing options (except "All" option)
            while (eggnameSelect.children.length > 1) {
                eggnameSelect.removeChild(eggnameSelect.lastChild);
            }
            while (projecteggSelect.children.length > 1) {
                projecteggSelect.removeChild(projecteggSelect.lastChild);
            }
            
            // Populate eggname dropdown
            if (data.eggnames && data.eggnames.length > 0) {
                data.eggnames.forEach(eggname => {
                    const option = document.createElement('option');
                    option.value = eggname;
                    option.textContent = eggname;
                    eggnameSelect.appendChild(option);
                });
                console.log(`Loaded ${data.eggnames.length} eggnames`);
            } else {
                console.log('No eggnames found');
            }
            
            // Populate projectegg dropdown
            if (data.projecteggs && data.projecteggs.length > 0) {
                data.projecteggs.forEach(projectegg => {
                    const option = document.createElement('option');
                    option.value = projectegg;
                    option.textContent = projectegg;
                    projecteggSelect.appendChild(option);
                });
                console.log(`Loaded ${data.projecteggs.length} projecteggs`);
            } else {
                console.log('No projecteggs found');
            }
        } else {
            console.error('API returned success=false:', data.error);
        }
    } catch (error) {
        console.error('Error loading dropdown options:', error);
    }
}

// Initialize Cytoscape
function initCytoscape() {
    cy = cytoscape({
        container: document.getElementById('cy'),
        elements: [],
        minZoom: 0.1,  // Allow zooming out much more (10% of original size)
        maxZoom: 3,    // Allow zooming in more (300% of original size)
        wheelSensitivity: 0.2,  // More granular mouse wheel zoom (smaller increments)
        style: [
            {
                selector: 'node[type="ip"][scanned="true"]',
                style: {
                    'background-color': '#3b82f6',
                    'label': 'data(label)',
                    'width': 30,
                    'height': 30,
                    'font-size': '10px',
                    'color': '#e2e8f0',
                    'text-wrap': 'wrap',
                    'text-max-width': '100px',
                    'text-valign': 'center',
                    'text-halign': 'center'
                }
            },
            {
                selector: 'node[type="ip"][scanned="false"]',
                style: {
                    'background-color': '#94a3b8',
                    'label': 'data(label)',
                    'width': 30,
                    'height': 30,
                    'font-size': '10px',
                    'color': '#e2e8f0',
                    'opacity': 0.6,
                    'text-wrap': 'wrap',
                    'text-max-width': '100px',
                    'text-valign': 'center',
                    'text-halign': 'center'
                }
            },
            {
                selector: 'node[type="cidr"]',
                style: {
                    'background-color': '#10b981',
                    'label': 'data(label)',
                    'width': 50,
                    'height': 50,
                    'font-size': '12px',
                    'color': '#e2e8f0',
                    'shape': 'round-rectangle',
                    'text-wrap': 'wrap',
                    'text-max-width': '150px'
                }
            },
            {
                selector: 'node[type="asn"]',
                style: {
                    'background-color': '#f59e0b',
                    'label': 'data(label)',
                    'width': 70,
                    'height': 70,
                    'font-size': '14px',
                    'color': '#e2e8f0',
                    'shape': 'round-rectangle',
                    'text-wrap': 'wrap',
                    'text-max-width': '200px',
                    'font-weight': 'bold'
                }
            },
            {
                selector: 'edge',
                style: {
                    'width': 2,
                    'line-color': '#64748b',
                    'target-arrow-color': '#64748b',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier',
                    'opacity': 0.6
                }
            },
            {
                selector: 'edge[type="belongs_to"]',
                style: {
                    'line-color': '#3b82f6',
                    'target-arrow-color': '#3b82f6'
                }
            },
            {
                selector: 'edge[type="owned_by"]',
                style: {
                    'line-color': '#10b981',
                    'target-arrow-color': '#10b981'
                }
            },
            {
                selector: 'edge[type="network"]',
                style: {
                    'line-color': '#8b5cf6',
                    'target-arrow-color': '#8b5cf6',
                    'width': 1.5,
                    'opacity': 0.4,
                    'line-style': 'dashed'
                }
            },
            {
                selector: 'edge[type="project"]',
                style: {
                    'line-color': '#ec4899',
                    'target-arrow-color': '#ec4899',
                    'width': 1.5,
                    'opacity': 0.5,
                    'line-style': 'dotted'
                }
            },
            {
                selector: 'node:selected',
                style: {
                    'border-width': 3,
                    'border-color': '#ec4899'
                }
            }
        ],
        layout: {
            name: 'dagre',
            rankDir: 'TB',
            spacingFactor: 1.5,
            nodeSep: 50,
            edgeSep: 20,
            rankSep: 100
        }
    });
    
    // Add node click handler
    cy.on('tap', 'node', function(evt) {
        const node = evt.target;
        selectedNode = node; // Store selected node
        
        // Highlight selected node in the list
        highlightNodeInList(node.id());
        
        // Show node details
        showNodeDetails(node);
    });
    
    // Add pan/zoom controls
    cy.on('pan', function() {});
    cy.on('zoom', function() {
        // Update zoom slider when zoom changes
        const currentZoom = cy.zoom();
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        if (zoomSlider) {
            zoomSlider.value = currentZoom;
        }
        if (zoomValue) {
            zoomValue.textContent = Math.round(currentZoom * 100) + '%';
        }
    });
    
    // Clustered drag functionality
    setupClusteredDrag();
}

// Helper function to convert RGB to hex
function rgbToHex(rgb) {
    if (!rgb) return '#3b82f6';
    if (rgb.startsWith('#')) return rgb;
    if (rgb.startsWith('rgb')) {
        const matches = rgb.match(/\d+/g);
        if (matches && matches.length >= 3) {
            return '#' + matches.map(x => {
                const hex = parseInt(x).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }
    }
    return '#3b82f6'; // Default fallback
}

// Function to build the node list
function buildNodeList() {
    if (!cy) return;
    
    const nodeList = document.getElementById('node-list');
    if (!nodeList) return;
    
    nodeList.innerHTML = '';
    
    // Group nodes by type
    const nodesByType = {
        'ip': [],
        'cidr': [],
        'asn': []
    };
    
    cy.nodes().forEach(function(node) {
        const nodeType = node.data('type');
        if (nodesByType[nodeType]) {
            nodesByType[nodeType].push(node);
        }
    });
    
    // Build list HTML grouped by type
    ['ip', 'cidr', 'asn'].forEach(function(type) {
        if (nodesByType[type].length === 0) return;
        
        const typeLabel = type.toUpperCase();
        const typeHeader = document.createElement('div');
        typeHeader.style.cssText = 'font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; margin-top: 15px; margin-bottom: 8px; font-weight: 600;';
        typeHeader.textContent = `${typeLabel} (${nodesByType[type].length})`;
        nodeList.appendChild(typeHeader);
        
        nodesByType[type].forEach(function(node) {
            const listItem = document.createElement('div');
            listItem.className = 'node-list-item';
            listItem.setAttribute('data-node-id', node.id());
            listItem.onclick = function() {
                selectNodeFromList(node.id());
            };
            
            const nodeType = document.createElement('div');
            nodeType.className = 'node-type';
            nodeType.textContent = node.data('type').toUpperCase();
            
            const nodeLabel = document.createElement('div');
            nodeLabel.className = 'node-label';
            nodeLabel.textContent = node.data('label');
            
            listItem.appendChild(nodeType);
            listItem.appendChild(nodeLabel);
            nodeList.appendChild(listItem);
        });
    });
}

// Function to highlight a node in the list
function highlightNodeInList(nodeId) {
    const listItems = document.querySelectorAll('.node-list-item');
    listItems.forEach(function(item) {
        if (item.getAttribute('data-node-id') === nodeId) {
            item.classList.add('selected');
            // Scroll into view
            item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        } else {
            item.classList.remove('selected');
        }
    });
}

// Function to select a node from the list
function selectNodeFromList(nodeId) {
    if (!cy) return;
    
    const node = cy.getElementById(nodeId);
    if (!node || node.length === 0) return;
    
    selectedNode = node;
    
    // Highlight in list
    highlightNodeInList(nodeId);
    
    // Show node details
    showNodeDetails(node);
    
    // Center and zoom on the node
    cy.center(node);
    cy.fit(node, 50); // 50px padding
}

// Make selectNodeFromList available globally
window.selectNodeFromList = selectNodeFromList;

// Function to show node details
function showNodeDetails(node) {
    const data = node.data('data');
    const currentColor = node.style('background-color') || '#3b82f6';
    const content = document.getElementById('node-details-content');
    
    // Build HTML content
    let html = '';
    
    // Node type and label
    html += `<div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #334155;">`;
    html += `<div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 5px;">Type</div>`;
    html += `<div style="font-size: 1.2rem; font-weight: 600; color: #3b82f6; margin-bottom: 10px;">${node.data('type').toUpperCase()}</div>`;
    html += `<div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 5px;">Label</div>`;
    html += `<div style="font-size: 1rem; color: #e2e8f0;">${node.data('label')}</div>`;
    html += `</div>`;
    
    // Node Color Control Section
    html += `<div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #334155;">`;
    html += `<div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 10px;">Node Color</div>`;
    html += `<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">`;
    html += `<input type="color" id="node-details-color-picker" value="${rgbToHex(currentColor)}" style="width: 60px; height: 35px; border: none; border-radius: 4px; cursor: pointer;">`;
    html += `<button onclick="updateNodeColor(document.getElementById('node-details-color-picker').value)" style="padding: 8px 16px; background: #3b82f6; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600; font-size: 0.85rem;">Apply Color</button>`;
    html += `</div>`;
    html += `<div style="font-size: 0.75rem; color: #64748b;">Change the color of this node</div>`;
    html += `</div>`;
    
    if (data) {
        // Scanned status
        if (data.scanned !== undefined) {
            html += `<div style="margin-bottom: 15px;">`;
            html += `<div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 5px;">Scanned</div>`;
            html += `<div style="display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 0.85rem; font-weight: 600; background: ${data.scanned ? 'rgba(16, 185, 129, 0.2)' : 'rgba(100, 116, 139, 0.2)'}; color: ${data.scanned ? '#10b981' : '#64748b'};">${data.scanned ? 'Yes' : 'No'}</div>`;
            html += `</div>`;
        }
        
        // Associated Eggs
        if (data.eggs && data.eggs.length > 0) {
            html += `<div style="margin-bottom: 15px;">`;
            html += `<div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 10px;">Associated Eggs (${data.eggs.length})</div>`;
            html += `<div style="display: flex; flex-direction: column; gap: 8px;">`;
            data.eggs.forEach((egg, idx) => {
                html += `<div style="padding: 10px; background: rgba(15, 23, 42, 0.6); border-radius: 6px; border: 1px solid #334155;">`;
                if (egg.eggname) html += `<div style="font-weight: 600; color: #e2e8f0; margin-bottom: 4px;">${egg.eggname}</div>`;
                if (egg.projectegg) html += `<div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 4px;">Project: ${egg.projectegg}</div>`;
                if (egg.domainname) html += `<div style="font-size: 0.85rem; color: #64748b;">Domain: ${egg.domainname}</div>`;
                html += `</div>`;
            });
            html += `</div>`;
            html += `</div>`;
        }
        
        // Other data fields
        const otherFields = [];
        for (const [key, value] of Object.entries(data)) {
            if (key !== 'scanned' && key !== 'eggs' && value !== null && value !== undefined) {
                if (key === 'ports' && Array.isArray(value)) {
                    otherFields.push({key: key, value: `${value.length} ports`, isArray: true, arrayData: value});
                } else if (key === 'services' && Array.isArray(value)) {
                    otherFields.push({key: key, value: value.join(', '), isArray: true, arrayData: value});
                } else {
                    otherFields.push({key: key, value: value, isArray: false});
                }
            }
        }
        
        if (otherFields.length > 0) {
            html += `<div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #334155;">`;
            html += `<div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 10px;">Additional Information</div>`;
            html += `<div style="display: flex; flex-direction: column; gap: 10px;">`;
            otherFields.forEach(field => {
                html += `<div>`;
                html += `<div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 4px;">${field.key.charAt(0).toUpperCase() + field.key.slice(1).replace(/_/g, ' ')}</div>`;
                if (field.isArray && field.arrayData.length > 0) {
                    html += `<div style="padding: 8px; background: rgba(15, 23, 42, 0.6); border-radius: 4px; font-size: 0.9rem; color: #e2e8f0;">${field.value}</div>`;
                } else {
                    html += `<div style="font-size: 0.9rem; color: #e2e8f0;">${field.value}</div>`;
                }
                html += `</div>`;
            });
            html += `</div>`;
            html += `</div>`;
        }
    }
    
    // Update content and show details section
    content.innerHTML = html;
    content.style.display = 'block'; // Make sure details section is visible
    
    // Add event listener for color picker changes
    const colorPicker = document.getElementById('node-details-color-picker');
    if (colorPicker) {
        colorPicker.addEventListener('input', function(e) {
            // Optional: update color in real-time as user picks
            // updateNodeColor(e.target.value);
        });
    }
    
    // Scroll details into view
    content.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Function to update node color (called from node details panel)
function updateNodeColor(color) {
    if (!selectedNode) {
        console.warn('No node selected');
        return;
    }
    
    // Update the node's style directly
    selectedNode.style('background-color', color);
    selectedNode.style('border-color', color);
    
    // Log the change
    const nodeId = selectedNode.id();
    const nodeLabel = selectedNode.data('label');
    console.log(`Updated node ${nodeId} (${nodeLabel}) color to ${color}`);
}

// Setup clustered drag functionality
function setupClusteredDrag() {
    if (!cy) return;
    
    cy.on('grab', 'node', function(evt) {
        if (!layoutSettings.clusteredDrag) return;
        
        const node = evt.target;
        dragState.isDragging = true;
        dragState.draggedNode = node;
        dragState.neighborPositions.clear();
        
        // Store initial positions of all neighbors
        const neighbors = node.neighborhood().nodes();
        neighbors.forEach(function(neighbor) {
            const pos = neighbor.position();
            dragState.neighborPositions.set(neighbor.id(), {
                x: pos.x,
                y: pos.y,
                relativeX: pos.x - node.position().x,
                relativeY: pos.y - node.position().y
            });
        });
    });
    
    cy.on('drag', 'node', function(evt) {
        if (!layoutSettings.clusteredDrag || !dragState.isDragging) return;
        
        const draggedNode = evt.target;
        if (draggedNode.id() !== dragState.draggedNode.id()) return;
        
        // For force-directed layouts (cose), use a softer approach that allows physics
        // Instead of locking positions, apply a gentle pull that physics can work with
        const layoutType = layoutSettings.type;
        const draggedPos = draggedNode.position();
        const neighbors = draggedNode.neighborhood().nodes();
        
        if (layoutType === 'cose') {
            // For force-directed: Apply gentle displacement instead of absolute positioning
            // This allows the physics engine to create the "bobbing" effect
            neighbors.forEach(function(neighbor) {
                const stored = dragState.neighborPositions.get(neighbor.id());
                if (stored) {
                    const targetX = draggedPos.x + stored.relativeX;
                    const targetY = draggedPos.y + stored.relativeY;
                    const currentPos = neighbor.position();
                    
                    // Apply 30% of the movement (soft pull) - physics will handle the rest
                    const pullFactor = 0.3;
                    const newX = currentPos.x + (targetX - currentPos.x) * pullFactor;
                    const newY = currentPos.y + (targetY - currentPos.y) * pullFactor;
                    
                    neighbor.position({ x: newX, y: newY });
                }
            });
        } else {
            // For non-physics layouts (dagre, grid, etc.): Use rigid positioning
            neighbors.forEach(function(neighbor) {
                const stored = dragState.neighborPositions.get(neighbor.id());
                if (stored) {
                    const newX = draggedPos.x + stored.relativeX;
                    const newY = draggedPos.y + stored.relativeY;
                    neighbor.position({ x: newX, y: newY });
                }
            });
        }
    });
    
    cy.on('free', 'node', function(evt) {
        dragState.isDragging = false;
        dragState.draggedNode = null;
        dragState.neighborPositions.clear();
        
        // For force-directed layouts, trigger a layout refresh to let physics settle
        if (layoutSettings.type === 'cose') {
            // Small layout refresh to let physics smooth out the positions
            setTimeout(function() {
                if (cy && !dragState.isDragging) {
                    cy.layout({
                        name: 'cose',
                        fit: false,
                        animate: true,
                        animationDuration: 500,
                        nodeRepulsion: 5000,
                        edgeElasticity: 50,
                        idealEdgeLength: Math.min(layoutSettings.physics.linkDistance, 40),
                        componentSpacing: 20,
                        gravity: layoutSettings.physics.centerForce * 0.5
                    }).run();
                }
            }, 100);
        }
    });
}

// Load graph data from API
async function loadGraph() {
    const level = document.getElementById('level-select').value;
    const asnFilter = document.getElementById('asn-filter').value;
    const onlyScannedEggs = document.getElementById('only-scanned-eggs').checked;
    const eggname = document.getElementById('eggname-select').value;
    const projectegg = document.getElementById('projectegg-select').value;
    
    // Get filter_cidr from URL query string if present
    const urlParams = new URLSearchParams(window.location.search);
    const filterCidr = urlParams.get('filter_cidr') || '';
    
    const params = new URLSearchParams({
        level: level,
        only_scanned_eggs: onlyScannedEggs
    });
    
    if (filterCidr) {
        params.append('filter_cidr', filterCidr);
    }
    if (asnFilter) {
        params.append('filter_asn', asnFilter);
    }
    if (eggname) {
        params.append('eggname', eggname);
    }
    if (projectegg) {
        params.append('projectegg', projectegg);
    }
    
    try {
        const response = await fetch(`/reconnaissance/api/network/graph/?${params}`);
        const data = await response.json();
        
        if (data.success) {
            console.log(`Graph loaded: ${data.nodes.length} nodes, ${data.edges.length} edges`);
            graphData = data;
            updateGraph();
            updateStats(data.stats);
            console.log('Graph updated and stats displayed');
        } else {
            console.error('Graph API error:', data.error);
            alert('Error loading graph: ' + data.error);
        }
    } catch (error) {
        console.error('Error loading graph:', error);
        alert('Error loading graph: ' + error.message);
    }
}

// Update graph visualization
function updateGraph() {
    if (!cy) {
        console.error('Cytoscape not initialized');
        return;
    }
    
    const elements = [];
    
    for (const node of graphData.nodes) {
        const nodeData = {
            id: node.id,
            label: node.label,
            type: node.type,
            scanned: node.data?.scanned ? 'true' : 'false'  // Set as direct attribute for CSS selector
        };
        
        // Add all node data properties
        if (node.data) {
            Object.assign(nodeData, node.data);
        }
        
        elements.push({
            data: nodeData
        });
    }
    
    for (const edge of graphData.edges) {
        elements.push({
            data: {
                id: edge.id || `edge_${edge.source}_${edge.target}`,
                source: edge.source,
                target: edge.target,
                type: edge.type,
                label: edge.label,
                // Store weight/similarity score if available from API
                weight: edge.weight || edge.similarity_score || edge.priority_score || null
            }
        });
    }
    
    console.log(`Updating graph with ${elements.length} elements (${graphData.nodes.length} nodes, ${graphData.edges.length} edges)`);
    
    cy.elements().remove();
    cy.add(elements);
    
    console.log(`Graph elements added. Total elements: ${cy.elements().length}`);
    
    // Apply layout - use grid if no edges, dagre if edges exist
    const hasEdges = elements.some(el => el.data.source && el.data.target);
    if (hasEdges) {
        console.log('Using dagre layout (has edges)');
        cy.layout({
            name: 'dagre',
            rankDir: 'TB',
            spacingFactor: 1.5,
            nodeSep: 50,
            edgeSep: 20,
            rankSep: 100
        }).run();
    } else {
        console.log('Using grid layout (no edges)');
        // Use grid layout when there are no edges
        const nodeCount = graphData.nodes.length;
        const cols = Math.ceil(Math.sqrt(nodeCount));
        cy.layout({
            name: 'grid',
            rows: Math.ceil(nodeCount / cols),
            cols: cols,
            spacing: 100
        }).run();
    }
    
    // Calculate degrees for all nodes (for degree-based sizing)
    calculateNodeDegrees();
    
    // Apply current visual settings first (colors)
    applyVisualSettingsToGraph();
    
    // Apply current layout (this will position nodes)
    applyLayout().then(() => {
        // Fit and center the graph
        cy.fit();
        cy.center();
        console.log('Graph layout applied and centered');
        
        // Apply dynamic edge coloring after layout settles
        updateEdgeColorsByWeight();
        
        // Build node list in right panel
        buildNodeList();
        
        // Initialize zoom slider
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        if (zoomSlider && zoomValue) {
            const currentZoom = cy.zoom();
            zoomSlider.value = currentZoom;
            zoomValue.textContent = Math.round(currentZoom * 100) + '%';
        }
    });
}

// Calculate node degrees (number of connections)
function calculateNodeDegrees() {
    if (!cy) return;
    
    cy.nodes().forEach(function(node) {
        const degree = node.degree();
        node.data('degree', degree);
    });
}

// Apply degree-based node sizing
function applyDegreeBasedSizing() {
    if (!cy) return;
    
    const nodes = cy.nodes();
    if (nodes.length === 0) return;
    
    // Find min and max degrees
    let minDegree = Infinity;
    let maxDegree = -Infinity;
    nodes.forEach(function(node) {
        const degree = node.data('degree') || 0;
        minDegree = Math.min(minDegree, degree);
        maxDegree = Math.max(maxDegree, degree);
    });
    
    // Base sizes by type
    const baseSizes = {
        'ip': visualSettings.nodeSize,
        'cidr': visualSettings.nodeSize + 20,
        'asn': visualSettings.nodeSize + 40
    };
    
    // Size multiplier range (1.0 to 2.5 based on degree)
    const minSize = 1.0;
    const maxSize = 2.5;
    const degreeRange = maxDegree - minDegree;
    
    nodes.forEach(function(node) {
        const degree = node.data('degree') || 0;
        const nodeType = node.data('type');
        const baseSize = baseSizes[nodeType] || visualSettings.nodeSize;
        
        let sizeMultiplier = 1.0;
        if (degreeRange > 0) {
            const normalizedDegree = (degree - minDegree) / degreeRange;
            sizeMultiplier = minSize + (maxSize - minSize) * normalizedDegree;
        }
        
        const newSize = Math.max(10, Math.min(150, baseSize * sizeMultiplier));
        node.style({
            'width': newSize,
            'height': newSize
        });
    });
}

// Apply layout based on current settings
function applyLayout() {
    if (!cy) return Promise.resolve();
    
    // Stop any existing running layout before creating a new one
    // Cytoscape automatically stops previous layouts when creating a new one,
    // but we'll try to explicitly stop if possible
    try {
        // Get all nodes and edges to check for active layout
        const elements = cy.elements();
        if (elements.length > 0) {
            // Try to stop any active layout by creating a dummy layout and stopping it
            // This is a workaround since Cytoscape doesn't expose layout state directly
            const dummyLayout = cy.layout({ name: 'preset', positions: function() { return undefined; }, fit: false, animate: false });
            dummyLayout.stop();
        }
    } catch (e) {
        // Ignore errors - layout might not be running
    }
    
    const layoutType = layoutSettings.type;
    let layoutConfig = {};
    
    switch(layoutType) {
        case 'dagre':
            layoutConfig = {
                name: 'dagre',
                rankDir: 'TB',
                spacingFactor: 1.5,
                nodeSep: 50,
                edgeSep: 20,
                rankSep: 100,
                animate: false
            };
            break;
        case 'cose':
            // Built-in CoSE layout (force-directed) with smooth animation and proper separation
            // Calculate graph metrics for dynamic repulsion
            const totalNodes = cy.nodes().length;
            const centerPull = Math.min(0.8, totalNodes / 500); // Scale center pull based on graph size
            
            // Aggressive repulsion to prevent stacking - base value is high, slider adds more
            // Formula: 5000 base + (slider * 500) gives range of 5000-10000 for dense graphs
            const baseRepelForce = 5000; // Aggressive base value to force separation
            const dynamicRepelForce = baseRepelForce + (layoutSettings.physics.repelForce * 500);
            
            layoutConfig = {
                name: 'cose',
                // Tighter clustering - bring linked nodes closer together
                idealEdgeLength: Math.min(layoutSettings.physics.linkDistance, 40), // Cap at 40px for tightness
                nodeOverlap: 20,
                refresh: 20,
                fit: true,
                padding: 30,
                randomize: true,  // Better initial distribution
                componentSpacing: 20,  // Reduced from 50 for tighter spacing between clusters
                // Aggressive repulsion to prevent stacking (5000-10000 range)
                nodeRepulsion: dynamicRepelForce,
                // Reduced edge elasticity for springy, less stiff connections (allows "bobbing")
                edgeElasticity: 50,  // Fixed low value for springy connections, independent of slider
                nestingFactor: 5,
                // Dynamic gravity based on graph size
                gravity: centerPull * layoutSettings.physics.centerForce,
                numIter: 2500,
                initialTemp: 200,
                coolingFactor: 0.95,
                minTemp: 1.0,
                // Smooth animation for "bobbing" effect (like Obsidian)
                animate: true,
                animationDuration: 1000,  // 1 second transition for noticeable "bobbing"
                animationEasing: 'ease-out'  // Slow down as nodes settle (organic feel)
            };
            break;
        case 'breadthfirst':
            layoutConfig = {
                name: 'breadthfirst',
                directed: true,
                roots: cy.nodes().filter(function(node) { return node.indegree() === 0; }),
                padding: 30,
                spacingFactor: 1.5,
                animate: true,
                animationDuration: 1000
            };
            break;
        case 'circle':
            layoutConfig = {
                name: 'circle',
                spacing: layoutSettings.physics.linkDistance,
                animate: true,
                animationDuration: 1000
            };
            break;
        case 'grid':
            const nodeCount = cy.nodes().length;
            const cols = Math.ceil(Math.sqrt(nodeCount));
            layoutConfig = {
                name: 'grid',
                rows: Math.ceil(nodeCount / cols),
                cols: cols,
                spacing: 100,
                animate: false
            };
            break;
    }
    
    // Show/hide physics controls based on layout type
    const physicsControls = document.getElementById('physics-controls');
    if (physicsControls) {
        if (layoutType === 'cose') {
            physicsControls.style.display = 'block';
        } else {
            physicsControls.style.display = 'none';
        }
    }
    
    // Create and run layout
    try {
        const layout = cy.layout(layoutConfig);
        layout.run();  // Explicitly run the layout
        
        // Return promise that resolves when layout stops
        return new Promise(function(resolve, reject) {
            layout.one('layoutstop', function() {
                cy.fit();
                cy.center();
                // Apply dynamic edge coloring after layout settles
                updateEdgeColorsByWeight();
                resolve();
            });
            
            // Fallback timeout in case layoutstop doesn't fire
            setTimeout(function() {
                cy.fit();
                cy.center();
                // Apply dynamic edge coloring after layout settles
                updateEdgeColorsByWeight();
                resolve();
            }, 2000);
        });
    } catch (error) {
        console.error('Failed to create layout:', error);
        showNotification('Layout not available: ' + layoutType, 'error');
        // Fallback to grid
        const nodeCount = cy.nodes().length;
        const cols = Math.ceil(Math.sqrt(nodeCount));
        const fallbackLayout = cy.layout({
            name: 'grid',
            rows: Math.ceil(nodeCount / cols),
            cols: cols,
            spacing: 100,
            animate: false
        });
        fallbackLayout.run();
        return Promise.resolve();
    }
}

// Apply physics settings
function applyPhysicsSettings() {
    layoutSettings.physics.linkForce = parseFloat(document.getElementById('link-force').value);
    layoutSettings.physics.linkDistance = parseInt(document.getElementById('link-distance').value);
    layoutSettings.physics.repelForce = parseFloat(document.getElementById('repel-force').value);
    layoutSettings.physics.centerForce = parseFloat(document.getElementById('center-force').value);
    
    // Update display values
    document.getElementById('link-force-value').textContent = layoutSettings.physics.linkForce.toFixed(1);
    document.getElementById('link-distance-value').textContent = layoutSettings.physics.linkDistance + 'px';
    document.getElementById('repel-force-value').textContent = layoutSettings.physics.repelForce.toFixed(1);
    document.getElementById('center-force-value').textContent = layoutSettings.physics.centerForce.toFixed(1);
    
    // Reapply layout with new physics settings
    applyLayout();
}

// Update statistics panel
function updateStats(stats) {
    document.getElementById('stat-nodes').textContent = stats.total_nodes || 0;
    document.getElementById('stat-edges').textContent = stats.total_edges || 0;
    document.getElementById('stat-ip-nodes').textContent = stats.ip_nodes || 0;
    document.getElementById('stat-cidr-nodes').textContent = stats.cidr_nodes || 0;
    document.getElementById('stat-asn-nodes').textContent = stats.asn_nodes || 0;
    document.getElementById('stat-scanned-ips').textContent = stats.scanned_ips || 0;
    document.getElementById('stat-unscanned-ips').textContent = stats.unscanned_ips || 0;
}

// Reset view
function resetView() {
    if (cy) {
        cy.fit();
        cy.center();
        // Reset zoom slider
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        if (zoomSlider) {
            zoomSlider.value = 1;
        }
        if (zoomValue) {
            zoomValue.textContent = '100%';
        }
    }
}

// Zoom in with smaller increments for more granular control
function zoomIn() {
    if (cy) {
        const currentZoom = cy.zoom();
        const newZoom = Math.min(currentZoom * 1.15, 3); // 15% increase, max 3x
        cy.zoom(newZoom);
        // Update slider
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        if (zoomSlider) {
            zoomSlider.value = newZoom;
        }
        if (zoomValue) {
            zoomValue.textContent = Math.round(newZoom * 100) + '%';
        }
    }
}

// Zoom out with smaller increments for more granular control
function zoomOut() {
    if (cy) {
        const currentZoom = cy.zoom();
        const newZoom = Math.max(currentZoom / 1.15, 0.1); // 15% decrease, min 0.1x
        cy.zoom(newZoom);
        // Update slider
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        if (zoomSlider) {
            zoomSlider.value = newZoom;
        }
        if (zoomValue) {
            zoomValue.textContent = Math.round(newZoom * 100) + '%';
        }
    }
}

// Set zoom level from slider
function setZoom(value) {
    if (cy) {
        const zoomLevel = parseFloat(value);
        cy.zoom(zoomLevel);
        // Update zoom value display
        const zoomValue = document.getElementById('zoom-value');
        if (zoomValue) {
            zoomValue.textContent = Math.round(zoomLevel * 100) + '%';
        }
    }
}

// Visual settings state
let visualSettings = {
    nodeColors: {
        scanned: '#3b82f6',
        unscanned: '#94a3b8',
        cidr: '#10b981',
        asn: '#f59e0b'
    },
    nodeSize: 30,
    edgeColor: '#64748b',
    edgeWidth: 2,
    edgeColorNetwork: '#8b5cf6',
    edgeColorProject: '#ec4899'
};

// Layout and physics settings
let layoutSettings = {
    type: 'dagre',
    clusteredDrag: true,
    physics: {
        linkForce: 1.5,      // Controls edge elasticity (spring stiffness) - not used in CoSE (fixed at 50)
        linkDistance: 30,    // Ideal distance between linked nodes (tighter clustering)
        repelForce: 5,      // Aggressive repulsion (5000 + 5*500 = 7500, prevents stacking)
        centerForce: 0.5     // Center gravity pull
    }
};

// Clustered drag state
let dragState = {
    isDragging: false,
    draggedNode: null,
    neighborPositions: new Map()
};

// Load visual settings from API
async function loadVisualSettings() {
    try {
        const response = await fetch('/reconnaissance/api/network/visual-settings/');
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.settings) {
                visualSettings = { ...visualSettings, ...data.settings };
                applyVisualSettingsToControls();
                applyVisualSettingsToGraph();
            }
        }
    } catch (error) {
        console.warn('Could not load visual settings:', error);
    }
}

// Apply visual settings to control inputs
function applyVisualSettingsToControls() {
    document.getElementById('node-color-scanned').value = visualSettings.nodeColors.scanned;
    document.getElementById('node-color-unscanned').value = visualSettings.nodeColors.unscanned;
    document.getElementById('node-color-cidr').value = visualSettings.nodeColors.cidr;
    document.getElementById('node-color-asn').value = visualSettings.nodeColors.asn;
    document.getElementById('node-size').value = visualSettings.nodeSize;
    document.getElementById('node-size-value').textContent = visualSettings.nodeSize + 'px';
    document.getElementById('edge-color').value = visualSettings.edgeColor;
    document.getElementById('edge-width').value = visualSettings.edgeWidth;
    document.getElementById('edge-width-value').textContent = visualSettings.edgeWidth.toFixed(1) + 'px';
    document.getElementById('edge-color-network').value = visualSettings.edgeColorNetwork;
    document.getElementById('edge-color-project').value = visualSettings.edgeColorProject;
    const weightColoringCheckbox = document.getElementById('weight-based-coloring');
    if (weightColoringCheckbox) {
        weightColoringCheckbox.checked = visualSettings.weightBasedColoring !== false; // Default to true
    }
}

// Apply visual settings to Cytoscape graph
function applyVisualSettingsToGraph() {
    if (!cy) return;
    
    // Update colors for all node types
    cy.nodes('[type="ip"][scanned="true"]').style({
        'background-color': visualSettings.nodeColors.scanned
    });
    
    cy.nodes('[type="ip"][scanned="false"]').style({
        'background-color': visualSettings.nodeColors.unscanned
    });
    
    cy.nodes('[type="cidr"]').style({
        'background-color': visualSettings.nodeColors.cidr
    });
    
    cy.nodes('[type="asn"]').style({
        'background-color': visualSettings.nodeColors.asn
    });
    
    // Fixed sizing based on Node Size slider (always use slider value)
    // Iterate through nodes individually to override stylesheet rules
    cy.nodes().forEach(function(node) {
        const nodeType = node.data('type');
        let nodeSize = visualSettings.nodeSize;
        
        // Apply size offsets based on node type
        if (nodeType === 'cidr') {
            nodeSize = visualSettings.nodeSize + 20;
        } else if (nodeType === 'asn') {
            nodeSize = visualSettings.nodeSize + 40;
        }
        // IP nodes use base size (no offset)
        
        // Apply size directly to each node to override stylesheet
        node.style('width', nodeSize);
        node.style('height', nodeSize);
    });
    
    // Update edges
    cy.edges().style({
        'line-color': visualSettings.edgeColor,
        'target-arrow-color': visualSettings.edgeColor,
        'width': visualSettings.edgeWidth
    });
    
    // Network edges
    cy.edges('[type="network"]').style({
        'line-color': visualSettings.edgeColorNetwork,
        'target-arrow-color': visualSettings.edgeColorNetwork
    });
    
    // Project edges
    cy.edges('[type="project"]').style({
        'line-color': visualSettings.edgeColorProject,
        'target-arrow-color': visualSettings.edgeColorProject
    });
    
    // Belongs to edges (IP -> CIDR)
    cy.edges('[type="belongs_to"]').style({
        'line-color': visualSettings.nodeColors.scanned,
        'target-arrow-color': visualSettings.nodeColors.scanned
    });
    
    // Owned by edges (CIDR -> ASN)
    cy.edges('[type="owned_by"]').style({
        'line-color': visualSettings.nodeColors.cidr,
        'target-arrow-color': visualSettings.nodeColors.cidr
    });
    
    // Apply dynamic edge coloring based on relationship weight (if available)
    updateEdgeColorsByWeight();
}

// Update edge colors dynamically based on relationship weight/similarity score
// This integrates the agent's Vector DB intelligence into the visualization
function updateEdgeColorsByWeight() {
    if (!cy || !visualSettings.weightBasedColoring) return;
    
    cy.edges().forEach(function(edge) {
        // Read the relationship weight (0.0 to 1.0) from the edge data
        // Default to 0.4 (medium-low confidence) if weight is not available
        const weight = edge.data('weight') || edge.data('similarity_score') || edge.data('priority_score') || 0.4;
        
        let edgeColor, edgeStyle, edgeWidth;
        
        if (weight >= 0.75) {
            // HIGH CRITICALITY / High Confidence (e.g., Admin path, high-value asset)
            edgeColor = '#f59e0b'; // Bright Yellow/Orange
            edgeStyle = 'solid';
            edgeWidth = 1.5;
        } else if (weight >= 0.50) {
            // MEDIUM CRITICALITY / Standard Relationship (e.g., Common CMS link)
            edgeColor = '#ec4899'; // Pink/Magenta (matches existing project color)
            edgeStyle = 'dashed';
            edgeWidth = 1.0;
        } else {
            // LOW CRITICALITY / Tentative Link (e.g., Generic API, low similarity)
            edgeColor = '#64748b'; // Faded Slate Gray
            edgeStyle = 'dotted';
            edgeWidth = 0.5;
        }
        
        // Apply dynamic styling
        // Preserve edge type colors for structural edges (belongs_to, owned_by) - these are hierarchy, not relationships
        const edgeType = edge.data('type');
        if (edgeType !== 'belongs_to' && edgeType !== 'owned_by') {
            // Apply weight-based coloring to relationship edges (network, project)
            edge.style({
                'line-color': edgeColor,
                'target-arrow-color': edgeColor,
                'line-style': edgeStyle,
                'width': edgeWidth,
                'opacity': weight < 0.50 ? 0.5 : 0.9 // Slight fade for low-confidence edges
            });
        }
        // Structural edges (belongs_to, owned_by) keep their default colors from applyVisualSettingsToGraph()
    });
}

// Assign custom color to node type
function assignNodeColor() {
    const nodeType = document.getElementById('node-type-select').value;
    const color = document.getElementById('custom-node-color').value;
    
    switch(nodeType) {
        case 'ip_scanned':
            visualSettings.nodeColors.scanned = color;
            document.getElementById('node-color-scanned').value = color;
            break;
        case 'ip_unscanned':
            visualSettings.nodeColors.unscanned = color;
            document.getElementById('node-color-unscanned').value = color;
            break;
        case 'cidr':
            visualSettings.nodeColors.cidr = color;
            document.getElementById('node-color-cidr').value = color;
            break;
        case 'asn':
            visualSettings.nodeColors.asn = color;
            document.getElementById('node-color-asn').value = color;
            break;
    }
    
    applyVisualSettingsToGraph();
}

// Apply and save visual settings
async function applyVisualSettings() {
    // Update settings from controls
    visualSettings.nodeColors.scanned = document.getElementById('node-color-scanned').value;
    visualSettings.nodeColors.unscanned = document.getElementById('node-color-unscanned').value;
    visualSettings.nodeColors.cidr = document.getElementById('node-color-cidr').value;
    visualSettings.nodeColors.asn = document.getElementById('node-color-asn').value;
    visualSettings.nodeSize = parseInt(document.getElementById('node-size').value);
    visualSettings.edgeColor = document.getElementById('edge-color').value;
    visualSettings.edgeWidth = parseFloat(document.getElementById('edge-width').value);
    visualSettings.edgeColorNetwork = document.getElementById('edge-color-network').value;
    visualSettings.edgeColorProject = document.getElementById('edge-color-project').value;
    visualSettings.weightBasedColoring = document.getElementById('weight-based-coloring').checked;
    
    // Apply to graph immediately
    applyVisualSettingsToGraph();
    
    // Save to API
    try {
        const response = await fetch('/reconnaissance/api/network/visual-settings/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ settings: visualSettings })
        });
        
        const data = await response.json();
        if (data.success) {
            showNotification('Visual settings saved successfully!', 'success');
        } else {
            showNotification('Error saving settings: ' + (data.error || 'Unknown error'), 'error');
        }
    } catch (error) {
        console.error('Error saving visual settings:', error);
        showNotification('Error saving settings: ' + error.message, 'error');
    }
}

// Reset visual settings to defaults
function resetVisualSettings() {
    visualSettings = {
        nodeColors: {
            scanned: '#3b82f6',
            unscanned: '#94a3b8',
            cidr: '#10b981',
            asn: '#f59e0b'
        },
        nodeSize: 30,
    edgeColor: '#64748b',
    edgeWidth: 1,
    edgeColorNetwork: '#8b5cf6',
    edgeColorProject: '#ec4899',
    weightBasedColoring: true  // Enable dynamic edge coloring based on relationship weight
};
    applyVisualSettingsToControls();
    applyVisualSettingsToGraph();
}

// Helper function to get CSRF token
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Show notification
function showNotification(message, type) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
        ${type === 'success' ? 'background: #10b981;' : 'background: #ef4444;'}
    `;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    // Set wrapper min-width since node details panel is always visible
    const wrapper = document.querySelector('.visualization-layout-wrapper');
    if (wrapper) {
        wrapper.style.minWidth = '2440px'; // 350px (left) + 20px + 1700px (graph) + 20px + 350px (right)
    }
    initCytoscape();
    
    // Setup control event listeners
    const nodeSizeSlider = document.getElementById('node-size');
    if (nodeSizeSlider) {
        // Real-time node size updates - no need to click Apply & Save
        nodeSizeSlider.addEventListener('input', function(e) {
            const sizeValue = parseInt(e.target.value) || 30;
            document.getElementById('node-size-value').textContent = sizeValue + 'px';
            visualSettings.nodeSize = sizeValue;
            
            // Apply node size changes immediately using the proven function
            // This ensures consistency with the rest of the codebase
            applyVisualSettingsToGraph();
        });
    }
    
    document.getElementById('edge-width').addEventListener('input', function(e) {
        const widthValue = parseFloat(e.target.value);
        document.getElementById('edge-width-value').textContent = widthValue.toFixed(1) + 'px';
        visualSettings.edgeWidth = widthValue;
        applyVisualSettingsToGraph();
    });
    
    // Color picker listeners for real-time preview (using 'input' for instant updates)
    ['node-color-scanned', 'node-color-unscanned', 'node-color-cidr', 'node-color-asn', 
     'edge-color', 'edge-color-network', 'edge-color-project'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            // Use 'input' event for real-time updates as user drags the color picker
            element.addEventListener('input', function(e) {
                if (id.startsWith('node-color-')) {
                    const type = id.replace('node-color-', '');
                    visualSettings.nodeColors[type] = e.target.value;
                } else if (id === 'edge-color') {
                    visualSettings.edgeColor = e.target.value;
                } else if (id === 'edge-color-network') {
                    visualSettings.edgeColorNetwork = e.target.value;
                } else if (id === 'edge-color-project') {
                    visualSettings.edgeColorProject = e.target.value;
                }
                applyVisualSettingsToGraph();
            });
            // Also listen to 'change' event as backup
            element.addEventListener('change', function(e) {
                if (id.startsWith('node-color-')) {
                    const type = id.replace('node-color-', '');
                    visualSettings.nodeColors[type] = e.target.value;
                } else if (id === 'edge-color') {
                    visualSettings.edgeColor = e.target.value;
                } else if (id === 'edge-color-network') {
                    visualSettings.edgeColorNetwork = e.target.value;
                } else if (id === 'edge-color-project') {
                    visualSettings.edgeColorProject = e.target.value;
                }
                applyVisualSettingsToGraph();
            });
        }
    });
    
    // Layout controls
    const layoutTypeSelect = document.getElementById('layout-type');
    if (layoutTypeSelect) {
        layoutTypeSelect.addEventListener('change', function(e) {
            layoutSettings.type = e.target.value;
            applyLayout();
        });
    }
    
    const clusteredDragCheckbox = document.getElementById('clustered-drag');
    if (clusteredDragCheckbox) {
        clusteredDragCheckbox.addEventListener('change', function(e) {
            layoutSettings.clusteredDrag = e.target.checked;
        });
    }
    
    // Weight-based edge coloring toggle
    const weightBasedColoringCheckbox = document.getElementById('weight-based-coloring');
    if (weightBasedColoringCheckbox) {
        weightBasedColoringCheckbox.checked = visualSettings.weightBasedColoring;
        weightBasedColoringCheckbox.addEventListener('change', function(e) {
            visualSettings.weightBasedColoring = e.target.checked;
            applyVisualSettingsToGraph(); // Reapply to update edge colors
        });
    }
    
    // Debounce helper for physics updates
    let physicsUpdateTimeout = null;
    function debouncedApplyLayout() {
        clearTimeout(physicsUpdateTimeout);
        physicsUpdateTimeout = setTimeout(function() {
            layoutSettings.physics.linkForce = parseFloat(document.getElementById('link-force').value);
            layoutSettings.physics.linkDistance = parseInt(document.getElementById('link-distance').value);
            layoutSettings.physics.repelForce = parseFloat(document.getElementById('repel-force').value);
            layoutSettings.physics.centerForce = parseFloat(document.getElementById('center-force').value);
            applyLayout();
        }, 300);  // 300ms debounce delay
    }
    
    // Physics controls - initialize with default values and real-time updates
    const linkForceSlider = document.getElementById('link-force');
    if (linkForceSlider) {
        linkForceSlider.value = layoutSettings.physics.linkForce;
        document.getElementById('link-force-value').textContent = layoutSettings.physics.linkForce.toFixed(1);
        linkForceSlider.addEventListener('input', function(e) {
            document.getElementById('link-force-value').textContent = parseFloat(e.target.value).toFixed(1);
            debouncedApplyLayout();
        });
    }
    
    const linkDistanceSlider = document.getElementById('link-distance');
    if (linkDistanceSlider) {
        linkDistanceSlider.value = layoutSettings.physics.linkDistance;
        document.getElementById('link-distance-value').textContent = layoutSettings.physics.linkDistance + 'px';
        linkDistanceSlider.addEventListener('input', function(e) {
            document.getElementById('link-distance-value').textContent = e.target.value + 'px';
            debouncedApplyLayout();
        });
    }
    
    const repelForceSlider = document.getElementById('repel-force');
    if (repelForceSlider) {
        repelForceSlider.value = layoutSettings.physics.repelForce;
        document.getElementById('repel-force-value').textContent = layoutSettings.physics.repelForce.toFixed(1);
        repelForceSlider.addEventListener('input', function(e) {
            document.getElementById('repel-force-value').textContent = parseFloat(e.target.value).toFixed(1);
            debouncedApplyLayout();
        });
    }
    
    const centerForceSlider = document.getElementById('center-force');
    if (centerForceSlider) {
        centerForceSlider.value = layoutSettings.physics.centerForce;
        document.getElementById('center-force-value').textContent = layoutSettings.physics.centerForce.toFixed(1);
        centerForceSlider.addEventListener('input', function(e) {
            document.getElementById('center-force-value').textContent = parseFloat(e.target.value).toFixed(1);
            debouncedApplyLayout();
        });
    }
    
    loadDropdownOptions().then(() => {
        // Add change handlers to reload graph when dropdowns change
        document.getElementById('eggname-select').addEventListener('change', loadGraph);
        document.getElementById('projectegg-select').addEventListener('change', loadGraph);
        document.getElementById('level-select').addEventListener('change', loadGraph);
        document.getElementById('asn-filter').addEventListener('change', loadGraph);
        document.getElementById('only-scanned-eggs').addEventListener('change', loadGraph);
    });
    
    // Load saved visual settings
    loadVisualSettings().then(() => {
        loadGraph();
    });
});
</script>

{% endblock %}

