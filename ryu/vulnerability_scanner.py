#!/usr/bin/env python3
"""
Ryu's Porygon-Z: Data Analyzer Service
Specializes in vulnerability scanning and data analysis
"""

import logging
import requests
import json
import re
from typing import Dict, List, Any, Optional
from datetime import datetime
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

class PorygonZDataAnalyzer:
    """
    Porygon-Z: Data Analyzer
    Gathers and analyzes data to identify vulnerabilities in a system.
    Uses Signal Beam and Tri Attack for comprehensive data analysis.
    """
    
    def __init__(self):
        self.logger = logger
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self.analysis_results = {}
        
    def _load_vulnerability_patterns(self) -> Dict[str, List[str]]:
        """Load vulnerability detection patterns"""
        return {
            'sql_injection': [
                r"error.*sql.*syntax",
                r"mysql.*error",
                r"postgresql.*error",
                r"oracle.*error",
                r"microsoft.*sql.*server.*error"
            ],
            'xss': [
                r"<script.*>",
                r"javascript:",
                r"onload=",
                r"onerror=",
                r"onclick="
            ],
            'csrf': [
                r"csrf.*token",
                r"authenticity.*token",
                r"_token"
            ],
            'directory_traversal': [
                r"\.\./",
                r"\.\.\\",
                r"file://",
                r"ftp://"
            ],
            'information_disclosure': [
                r"apache.*version",
                r"nginx.*version",
                r"server.*version",
                r"x-powered-by",
                r"x-aspnet-version"
            ]
        }
    
    def signal_beam_analysis(self, target_url: str) -> Dict[str, Any]:
        """
        Signal Beam: Comprehensive data analysis
        Analyzes target for potential vulnerabilities and security issues
        """
        self.logger.info(f"[Porygon-Z] Signal Beam analysis on: {target_url}")
        
        results = {
            'target': target_url,
            'analysis_type': 'signal_beam',
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': [],
            'security_headers': {},
            'technology_stack': {},
            'recommendations': []
        }
        
        try:
            # Perform HTTP analysis
            response = requests.get(target_url, timeout=10, allow_redirects=True)
            
            # Analyze response headers
            results['security_headers'] = self._analyze_security_headers(response.headers)
            
            # Analyze response content
            results['vulnerabilities'] = self._analyze_content_vulnerabilities(response.text)
            
            # Analyze technology stack
            results['technology_stack'] = self._analyze_technology_stack(response.headers, response.text)
            
            # Generate recommendations
            results['recommendations'] = self._generate_security_recommendations(results)
            
        except Exception as e:
            self.logger.error(f"[Porygon-Z] Signal Beam analysis failed: {e}")
            results['error'] = str(e)
        
        return results
    
    def tri_attack_analysis(self, target_url: str) -> Dict[str, Any]:
        """
        Tri Attack: Multi-vector vulnerability assessment
        Performs three-pronged attack simulation for vulnerability testing
        """
        self.logger.info(f"[Porygon-Z] Tri Attack analysis on: {target_url}")
        
        results = {
            'target': target_url,
            'analysis_type': 'tri_attack',
            'timestamp': datetime.now().isoformat(),
            'attack_vectors': {
                'injection_attacks': [],
                'authentication_bypass': [],
                'authorization_flaws': []
            },
            'severity_score': 0,
            'recommendations': []
        }
        
        try:
            # Vector 1: Injection Attack Testing
            results['attack_vectors']['injection_attacks'] = self._test_injection_attacks(target_url)
            
            # Vector 2: Authentication Bypass Testing
            results['attack_vectors']['authentication_bypass'] = self._test_auth_bypass(target_url)
            
            # Vector 3: Authorization Flaw Testing
            results['attack_vectors']['authorization_flaws'] = self._test_authorization_flaws(target_url)
            
            # Calculate severity score
            results['severity_score'] = self._calculate_severity_score(results)
            
        except Exception as e:
            self.logger.error(f"[Porygon-Z] Tri Attack analysis failed: {e}")
            results['error'] = str(e)
        
        return results
    
    def _analyze_security_headers(self, headers: Dict[str, str]) -> Dict[str, Any]:
        """Analyze security headers"""
        security_analysis = {
            'present_headers': [],
            'missing_headers': [],
            'security_score': 0
        }
        
        required_headers = [
            'X-Content-Type-Options',
            'X-Frame-Options',
            'X-XSS-Protection',
            'Strict-Transport-Security',
            'Content-Security-Policy'
        ]
        
        for header in required_headers:
            if header in headers:
                security_analysis['present_headers'].append(header)
                security_analysis['security_score'] += 20
            else:
                security_analysis['missing_headers'].append(header)
        
        return security_analysis
    
    def _analyze_content_vulnerabilities(self, content: str) -> List[Dict[str, Any]]:
        """Analyze content for vulnerability patterns"""
        vulnerabilities = []
        
        for vuln_type, patterns in self.vulnerability_patterns.items():
            for pattern in patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    vulnerabilities.append({
                        'type': vuln_type,
                        'pattern': pattern,
                        'severity': self._get_vulnerability_severity(vuln_type)
                    })
        
        return vulnerabilities
    
    def _analyze_technology_stack(self, headers: Dict[str, str], content: str) -> Dict[str, Any]:
        """Analyze technology stack"""
        tech_stack = {
            'web_server': 'unknown',
            'framework': 'unknown',
            'database': 'unknown',
            'programming_language': 'unknown'
        }
        
        # Analyze headers for technology indicators
        server_header = headers.get('Server', '').lower()
        if 'apache' in server_header:
            tech_stack['web_server'] = 'Apache'
        elif 'nginx' in server_header:
            tech_stack['web_server'] = 'Nginx'
        elif 'iis' in server_header:
            tech_stack['web_server'] = 'IIS'
        
        # Analyze content for framework indicators
        if 'django' in content.lower():
            tech_stack['framework'] = 'Django'
        elif 'flask' in content.lower():
            tech_stack['framework'] = 'Flask'
        elif 'rails' in content.lower():
            tech_stack['framework'] = 'Ruby on Rails'
        
        return tech_stack
    
    def _generate_security_recommendations(self, analysis_results: Dict[str, Any]) -> List[str]:
        """Generate security recommendations based on analysis"""
        recommendations = []
        
        # Check for missing security headers
        if analysis_results['security_headers']['missing_headers']:
            recommendations.append("Implement missing security headers")
        
        # Check for vulnerabilities
        if analysis_results['vulnerabilities']:
            recommendations.append("Address identified vulnerabilities")
        
        # Check for information disclosure
        if analysis_results['technology_stack']['web_server'] != 'unknown':
            recommendations.append("Consider hiding server version information")
        
        return recommendations
    
    def _test_injection_attacks(self, target_url: str) -> List[Dict[str, Any]]:
        """Test for injection vulnerabilities"""
        injection_tests = []
        
        # SQL Injection test payloads
        sql_payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users; --"]
        
        for payload in sql_payloads:
            try:
                test_url = f"{target_url}?id={payload}"
                response = requests.get(test_url, timeout=5)
                
                if any(keyword in response.text.lower() for keyword in ['sql', 'mysql', 'postgresql', 'oracle']):
                    injection_tests.append({
                        'type': 'sql_injection',
                        'payload': payload,
                        'vulnerable': True
                    })
            except:
                pass
        
        return injection_tests
    
    def _test_auth_bypass(self, target_url: str) -> List[Dict[str, Any]]:
        """Test for authentication bypass vulnerabilities"""
        bypass_tests = []
        
        # Common bypass techniques
        bypass_payloads = [
            "admin",
            "administrator", 
            "root",
            "test",
            "guest"
        ]
        
        for payload in bypass_payloads:
            try:
                test_url = f"{target_url}/admin"
                response = requests.get(test_url, timeout=5)
                
                if response.status_code == 200 and 'login' not in response.text.lower():
                    bypass_tests.append({
                        'type': 'auth_bypass',
                        'payload': payload,
                        'vulnerable': True
                    })
            except:
                pass
        
        return bypass_tests
    
    def _test_authorization_flaws(self, target_url: str) -> List[Dict[str, Any]]:
        """Test for authorization flaws"""
        auth_tests = []
        
        # Test for directory traversal
        traversal_payloads = ["../", "..\\", "....//", "....\\\\"]
        
        for payload in traversal_payloads:
            try:
                test_url = f"{target_url}/{payload}etc/passwd"
                response = requests.get(test_url, timeout=5)
                
                if 'root:' in response.text:
                    auth_tests.append({
                        'type': 'directory_traversal',
                        'payload': payload,
                        'vulnerable': True
                    })
            except:
                pass
        
        return auth_tests
    
    def _calculate_severity_score(self, results: Dict[str, Any]) -> int:
        """Calculate overall severity score"""
        score = 0
        
        for vector_type, tests in results['attack_vectors'].items():
            for test in tests:
                if test.get('vulnerable', False):
                    if test['type'] == 'sql_injection':
                        score += 30
                    elif test['type'] == 'auth_bypass':
                        score += 25
                    elif test['type'] == 'directory_traversal':
                        score += 35
        
        return min(score, 100)  # Cap at 100
    
    def _get_vulnerability_severity(self, vuln_type: str) -> str:
        """Get severity level for vulnerability type"""
        severity_map = {
            'sql_injection': 'critical',
            'xss': 'high',
            'csrf': 'medium',
            'directory_traversal': 'critical',
            'information_disclosure': 'low'
        }
        return severity_map.get(vuln_type, 'medium')


