#!/usr/bin/env python3
"""
Ryu's Alakazam: Vulnerability Scanner Service
Utilizes computational power to analyze data for potential breaches
"""

import logging
import requests
import re
import json
from typing import Dict, List, Any, Optional
from datetime import datetime
from urllib.parse import urlparse, urljoin

logger = logging.getLogger(__name__)

class AlakazamVulnerabilityScanner:
    """
    Alakazam: Vulnerability Scanner
    Utilizes computational power to analyze data for potential breaches.
    Uses Psyshock and Confusion for vulnerability scanning and analysis.
    """
    
    def __init__(self):
        self.logger = logger
        self.vulnerability_database = {}
        self.scan_results = {}
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        
    def _load_vulnerability_patterns(self) -> Dict[str, List[str]]:
        """Load comprehensive vulnerability patterns"""
        return {
            'sql_injection': [
                r"error.*sql.*syntax",
                r"mysql.*error",
                r"postgresql.*error",
                r"oracle.*error",
                r"microsoft.*sql.*server.*error",
                r"sql.*injection",
                r"union.*select",
                r"drop.*table"
            ],
            'xss': [
                r"<script.*>",
                r"javascript:",
                r"onload=",
                r"onerror=",
                r"onclick=",
                r"alert\(",
                r"document\.cookie"
            ],
            'csrf': [
                r"csrf.*token",
                r"authenticity.*token",
                r"_token",
                r"csrfmiddlewaretoken"
            ],
            'directory_traversal': [
                r"\.\./",
                r"\.\.\\",
                r"file://",
                r"ftp://",
                r"\.\.%2f",
                r"\.\.%5c"
            ],
            'command_injection': [
                r"system\(",
                r"exec\(",
                r"shell_exec",
                r"passthru\(",
                r"popen\(",
                r"proc_open"
            ],
            'ldap_injection': [
                r"ldap.*error",
                r"ldap.*syntax",
                r"ldap.*search"
            ],
            'xml_injection': [
                r"xml.*error",
                r"xml.*syntax",
                r"xml.*parser"
            ],
            'path_traversal': [
                r"\.\./",
                r"\.\.\\",
                r"\.\.%2f",
                r"\.\.%5c",
                r"\.\.%252f",
                r"\.\.%255c"
            ]
        }
    
    def psyshock_scan(self, target_url: str) -> Dict[str, Any]:
        """
        Psyshock: High-impact vulnerability scan
        Performs comprehensive vulnerability scanning with high precision
        """
        self.logger.info(f"[Alakazam] Psyshock scan on: {target_url}")
        
        results = {
            'target': target_url,
            'scan_type': 'psyshock',
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': [],
            'scan_metrics': {},
            'recommendations': []
        }
        
        try:
            # Perform comprehensive scan
            response = requests.get(target_url, timeout=15, allow_redirects=True)
            
            # Scan for vulnerabilities
            results['vulnerabilities'] = self._scan_for_vulnerabilities(target_url, response)
            
            # Calculate scan metrics
            results['scan_metrics'] = self._calculate_scan_metrics(results)
            
            # Generate recommendations
            results['recommendations'] = self._generate_vulnerability_recommendations(results)
            
        except Exception as e:
            self.logger.error(f"[Alakazam] Psyshock scan failed: {e}")
            results['error'] = str(e)
        
        return results
    
    def confusion_analysis(self, target_url: str) -> Dict[str, Any]:
        """
        Confusion: Complex vulnerability analysis
        Performs deep analysis of complex vulnerability patterns
        """
        self.logger.info(f"[Alakazam] Confusion analysis on: {target_url}")
        
        results = {
            'target': target_url,
            'analysis_type': 'confusion',
            'timestamp': datetime.now().isoformat(),
            'complex_vulnerabilities': [],
            'attack_vectors': [],
            'exploit_potential': {},
            'mitigation_strategies': []
        }
        
        try:
            # Analyze complex vulnerability patterns
            results['complex_vulnerabilities'] = self._analyze_complex_vulnerabilities(target_url)
            
            # Identify attack vectors
            results['attack_vectors'] = self._identify_attack_vectors(target_url)
            
            # Assess exploit potential
            results['exploit_potential'] = self._assess_exploit_potential(results)
            
            # Develop mitigation strategies
            results['mitigation_strategies'] = self._develop_mitigation_strategies(results)
            
        except Exception as e:
            self.logger.error(f"[Alakazam] Confusion analysis failed: {e}")
            results['error'] = str(e)
        
        return results
    
    def _scan_for_vulnerabilities(self, target_url: str, response) -> List[Dict[str, Any]]:
        """Scan for various types of vulnerabilities"""
        vulnerabilities = []
        
        # Scan response content
        content = response.text
        headers = response.headers
        
        # Check for SQL injection patterns
        for pattern in self.vulnerability_patterns['sql_injection']:
            if re.search(pattern, content, re.IGNORECASE):
                vulnerabilities.append({
                    'type': 'sql_injection',
                    'severity': 'critical',
                    'description': 'Potential SQL injection vulnerability detected',
                    'pattern': pattern,
                    'location': 'response_content'
                })
        
        # Check for XSS patterns
        for pattern in self.vulnerability_patterns['xss']:
            if re.search(pattern, content, re.IGNORECASE):
                vulnerabilities.append({
                    'type': 'xss',
                    'severity': 'high',
                    'description': 'Potential XSS vulnerability detected',
                    'pattern': pattern,
                    'location': 'response_content'
                })
        
        # Check for directory traversal patterns
        for pattern in self.vulnerability_patterns['directory_traversal']:
            if re.search(pattern, content, re.IGNORECASE):
                vulnerabilities.append({
                    'type': 'directory_traversal',
                    'severity': 'high',
                    'description': 'Potential directory traversal vulnerability detected',
                    'pattern': pattern,
                    'location': 'response_content'
                })
        
        # Check for command injection patterns
        for pattern in self.vulnerability_patterns['command_injection']:
            if re.search(pattern, content, re.IGNORECASE):
                vulnerabilities.append({
                    'type': 'command_injection',
                    'severity': 'critical',
                    'description': 'Potential command injection vulnerability detected',
                    'pattern': pattern,
                    'location': 'response_content'
                })
        
        # Check headers for information disclosure
        if 'Server' in headers:
            vulnerabilities.append({
                'type': 'information_disclosure',
                'severity': 'low',
                'description': 'Server version information disclosed',
                'pattern': headers['Server'],
                'location': 'response_headers'
            })
        
        return vulnerabilities
    
    def _analyze_complex_vulnerabilities(self, target_url: str) -> List[Dict[str, Any]]:
        """Analyze complex vulnerability patterns"""
        complex_vulnerabilities = []
        
        try:
            # Test for parameter pollution
            test_params = {
                'id': ['1', '1; DROP TABLE users; --', '1\' OR \'1\'=\'1'],
                'user': ['admin', 'administrator', 'root'],
                'file': ['../../../etc/passwd', '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts']
            }
            
            for param, values in test_params.items():
                for value in values:
                    try:
                        test_url = f"{target_url}?{param}={value}"
                        response = requests.get(test_url, timeout=5)
                        
                        # Check for error patterns
                        if any(keyword in response.text.lower() for keyword in ['error', 'exception', 'warning']):
                            complex_vulnerabilities.append({
                                'type': 'parameter_pollution',
                                'severity': 'medium',
                                'description': f'Parameter pollution detected in {param}',
                                'test_value': value,
                                'response_indicator': 'error_response'
                            })
                    except:
                        pass
        
        except Exception as e:
            self.logger.error(f"Complex vulnerability analysis failed: {e}")
        
        return complex_vulnerabilities
    
    def _identify_attack_vectors(self, target_url: str) -> List[Dict[str, Any]]:
        """Identify potential attack vectors"""
        attack_vectors = []
        
        try:
            # Common attack endpoints
            attack_endpoints = [
                '/admin',
                '/login',
                '/api',
                '/upload',
                '/config',
                '/backup',
                '/phpmyadmin',
                '/wp-admin',
                '/administrator'
            ]
            
            for endpoint in attack_endpoints:
                try:
                    test_url = urljoin(target_url, endpoint)
                    response = requests.get(test_url, timeout=5)
                    
                    if response.status_code == 200:
                        attack_vectors.append({
                            'endpoint': endpoint,
                            'accessible': True,
                            'risk_level': 'high' if 'admin' in endpoint else 'medium',
                            'response_size': len(response.text)
                        })
                except:
                    pass
        
        except Exception as e:
            self.logger.error(f"Attack vector identification failed: {e}")
        
        return attack_vectors
    
    def _assess_exploit_potential(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Assess the potential for exploitation"""
        exploit_potential = {
            'overall_risk': 'low',
            'exploit_difficulty': 'unknown',
            'impact_level': 'unknown',
            'likelihood': 'unknown'
        }
        
        vulnerabilities = analysis_results.get('complex_vulnerabilities', [])
        attack_vectors = analysis_results.get('attack_vectors', [])
        
        # Calculate overall risk
        critical_vulns = sum(1 for vuln in vulnerabilities if vuln['severity'] == 'critical')
        high_vulns = sum(1 for vuln in vulnerabilities if vuln['severity'] == 'high')
        accessible_vectors = sum(1 for vector in attack_vectors if vector['accessible'])
        
        if critical_vulns > 0 or (high_vulns > 1 and accessible_vectors > 2):
            exploit_potential['overall_risk'] = 'critical'
            exploit_potential['exploit_difficulty'] = 'easy'
            exploit_potential['impact_level'] = 'high'
            exploit_potential['likelihood'] = 'high'
        elif high_vulns > 0 or accessible_vectors > 1:
            exploit_potential['overall_risk'] = 'high'
            exploit_potential['exploit_difficulty'] = 'medium'
            exploit_potential['impact_level'] = 'medium'
            exploit_potential['likelihood'] = 'medium'
        elif vulnerabilities or attack_vectors:
            exploit_potential['overall_risk'] = 'medium'
            exploit_potential['exploit_difficulty'] = 'hard'
            exploit_potential['impact_level'] = 'low'
            exploit_potential['likelihood'] = 'low'
        
        return exploit_potential
    
    def _develop_mitigation_strategies(self, analysis_results: Dict[str, Any]) -> List[str]:
        """Develop mitigation strategies based on analysis"""
        strategies = []
        
        vulnerabilities = analysis_results.get('complex_vulnerabilities', [])
        exploit_potential = analysis_results.get('exploit_potential', {})
        
        # Develop strategies based on vulnerability types
        vuln_types = [vuln['type'] for vuln in vulnerabilities]
        
        if 'sql_injection' in vuln_types:
            strategies.append("Implement parameterized queries and input validation")
        
        if 'xss' in vuln_types:
            strategies.append("Implement output encoding and Content Security Policy")
        
        if 'directory_traversal' in vuln_types:
            strategies.append("Implement path validation and access controls")
        
        if 'command_injection' in vuln_types:
            strategies.append("Implement command validation and sandboxing")
        
        # General strategies based on risk level
        overall_risk = exploit_potential.get('overall_risk', 'low')
        if overall_risk in ['critical', 'high']:
            strategies.append("Implement immediate security patches")
            strategies.append("Deploy web application firewall")
            strategies.append("Conduct security code review")
        
        return strategies
    
    def _calculate_scan_metrics(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate scan metrics"""
        metrics = {
            'total_vulnerabilities': 0,
            'critical_count': 0,
            'high_count': 0,
            'medium_count': 0,
            'low_count': 0,
            'scan_coverage': 0
        }
        
        vulnerabilities = scan_results.get('vulnerabilities', [])
        
        for vuln in vulnerabilities:
            metrics['total_vulnerabilities'] += 1
            severity = vuln.get('severity', 'low')
            
            if severity == 'critical':
                metrics['critical_count'] += 1
            elif severity == 'high':
                metrics['high_count'] += 1
            elif severity == 'medium':
                metrics['medium_count'] += 1
            else:
                metrics['low_count'] += 1
        
        # Calculate scan coverage (simplified)
        metrics['scan_coverage'] = min(100, len(vulnerabilities) * 10)
        
        return metrics
    
    def _generate_vulnerability_recommendations(self, scan_results: Dict[str, Any]) -> List[str]:
        """Generate vulnerability remediation recommendations"""
        recommendations = []
        
        vulnerabilities = scan_results.get('vulnerabilities', [])
        metrics = scan_results.get('scan_metrics', {})
        
        # Generate recommendations based on metrics
        if metrics.get('critical_count', 0) > 0:
            recommendations.append("Address critical vulnerabilities immediately")
        
        if metrics.get('high_count', 0) > 2:
            recommendations.append("Prioritize high-severity vulnerabilities")
        
        if metrics.get('total_vulnerabilities', 0) > 10:
            recommendations.append("Conduct comprehensive security review")
        
        # Generate specific recommendations based on vulnerability types
        vuln_types = [vuln['type'] for vuln in vulnerabilities]
        
        if 'sql_injection' in vuln_types:
            recommendations.append("Implement SQL injection prevention measures")
        
        if 'xss' in vuln_types:
            recommendations.append("Implement XSS prevention measures")
        
        if 'information_disclosure' in vuln_types:
            recommendations.append("Hide sensitive information in headers")
        
        return recommendations
    
    def update_vulnerability_database(self, vulnerability_data: Dict[str, Any]):
        """Update the vulnerability database"""
        self.vulnerability_database.update(vulnerability_data)
        self.logger.info(f"[Alakazam] Updated vulnerability database with {len(vulnerability_data)} entries")
    
    def get_scan_statistics(self) -> Dict[str, Any]:
        """Get scan statistics"""
        return {
            'vulnerability_database_size': len(self.vulnerability_database),
            'scan_results_count': len(self.scan_results),
            'vulnerability_patterns_count': sum(len(patterns) for patterns in self.vulnerability_patterns.values())
        }


